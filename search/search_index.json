{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. cd [dir-name] - redirect to the directory. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs gh-deploy - deploy the gh-page site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Preface"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. cd [dir-name] - redirect to the directory. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs gh-deploy - deploy the gh-page site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"template/","text":"Project Title Readme file temple quotes from PurpleBooth Github: template Getting Started These instructions will get you a copy of the project up and running on your local machine for development and testing purposes. See deployment for notes on how to deploy the project on a live system. Prerequisites What things you need to install the software and how to install them Give examples Installing A step by step series of examples that tell you how to get a development env running Say what the step will be Give the example And repeat until finished End with an example of getting some data out of the system or using it for a little demo Running the tests Explain how to run the automated tests for this system Break down into end to end tests Explain what these tests test and why Give an example And coding style tests Explain what these tests test and why Give an example Deployment Add additional notes about how to deploy this on a live system Built With Dropwizard - The web framework used Maven - Dependency Management ROME - Used to generate RSS Feeds Contributing Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us. Versioning We use SemVer for versioning. For the versions available, see the tags on this repository . Authors Billie Thompson - Initial work - PurpleBooth See also the list of contributors who participated in this project. License This project is licensed under the MIT License - see the LICENSE.md file for details Acknowledgments Hat tip to anyone whose code was used Inspiration etc","title":"Template"},{"location":"template/#project-title","text":"Readme file temple quotes from PurpleBooth Github: template","title":"Project Title"},{"location":"template/#getting-started","text":"These instructions will get you a copy of the project up and running on your local machine for development and testing purposes. See deployment for notes on how to deploy the project on a live system.","title":"Getting Started"},{"location":"template/#prerequisites","text":"What things you need to install the software and how to install them Give examples","title":"Prerequisites"},{"location":"template/#installing","text":"A step by step series of examples that tell you how to get a development env running Say what the step will be Give the example And repeat until finished End with an example of getting some data out of the system or using it for a little demo","title":"Installing"},{"location":"template/#running-the-tests","text":"Explain how to run the automated tests for this system","title":"Running the tests"},{"location":"template/#break-down-into-end-to-end-tests","text":"Explain what these tests test and why Give an example","title":"Break down into end to end tests"},{"location":"template/#and-coding-style-tests","text":"Explain what these tests test and why Give an example","title":"And coding style tests"},{"location":"template/#deployment","text":"Add additional notes about how to deploy this on a live system","title":"Deployment"},{"location":"template/#built-with","text":"Dropwizard - The web framework used Maven - Dependency Management ROME - Used to generate RSS Feeds","title":"Built With"},{"location":"template/#contributing","text":"Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us.","title":"Contributing"},{"location":"template/#versioning","text":"We use SemVer for versioning. For the versions available, see the tags on this repository .","title":"Versioning"},{"location":"template/#authors","text":"Billie Thompson - Initial work - PurpleBooth See also the list of contributors who participated in this project.","title":"Authors"},{"location":"template/#license","text":"This project is licensed under the MIT License - see the LICENSE.md file for details","title":"License"},{"location":"template/#acknowledgments","text":"Hat tip to anyone whose code was used Inspiration etc","title":"Acknowledgments"},{"location":"DynamicProgramming/01backpack/","text":"Dynamic Programming Readme file temple quotes from PurpleBooth Github: template 0/1 Backpack LeetCode 416. Partition Equal Subset Sum Prerequisites What things you need to install the software and how to install them Give examples Installing A step by step series of examples that tell you how to get a development env running Say what the step will be Give the example And repeat until finished End with an example of getting some data out of the system or using it for a little demo Running the tests Explain how to run the automated tests for this system Break down into end to end tests Explain what these tests test and why Give an example And coding style tests Explain what these tests test and why Give an example Deployment Add additional notes about how to deploy this on a live system Built With Dropwizard - The web framework used Maven - Dependency Management ROME - Used to generate RSS Feeds Contributing Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us. Versioning We use SemVer for versioning. For the versions available, see the tags on this repository . Authors Billie Thompson - Initial work - PurpleBooth See also the list of contributors who participated in this project. License This project is licensed under the MIT License - see the LICENSE.md file for details Acknowledgments Hat tip to anyone whose code was used Inspiration etc","title":"0/1 Backpack"},{"location":"DynamicProgramming/01backpack/#dynamic-programming","text":"Readme file temple quotes from PurpleBooth Github: template","title":"Dynamic Programming"},{"location":"DynamicProgramming/01backpack/#01-backpack","text":"LeetCode 416. Partition Equal Subset Sum","title":"0/1 Backpack"},{"location":"DynamicProgramming/01backpack/#prerequisites","text":"What things you need to install the software and how to install them Give examples","title":"Prerequisites"},{"location":"DynamicProgramming/01backpack/#installing","text":"A step by step series of examples that tell you how to get a development env running Say what the step will be Give the example And repeat until finished End with an example of getting some data out of the system or using it for a little demo","title":"Installing"},{"location":"DynamicProgramming/01backpack/#running-the-tests","text":"Explain how to run the automated tests for this system","title":"Running the tests"},{"location":"DynamicProgramming/01backpack/#break-down-into-end-to-end-tests","text":"Explain what these tests test and why Give an example","title":"Break down into end to end tests"},{"location":"DynamicProgramming/01backpack/#and-coding-style-tests","text":"Explain what these tests test and why Give an example","title":"And coding style tests"},{"location":"DynamicProgramming/01backpack/#deployment","text":"Add additional notes about how to deploy this on a live system","title":"Deployment"},{"location":"DynamicProgramming/01backpack/#built-with","text":"Dropwizard - The web framework used Maven - Dependency Management ROME - Used to generate RSS Feeds","title":"Built With"},{"location":"DynamicProgramming/01backpack/#contributing","text":"Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us.","title":"Contributing"},{"location":"DynamicProgramming/01backpack/#versioning","text":"We use SemVer for versioning. For the versions available, see the tags on this repository .","title":"Versioning"},{"location":"DynamicProgramming/01backpack/#authors","text":"Billie Thompson - Initial work - PurpleBooth See also the list of contributors who participated in this project.","title":"Authors"},{"location":"DynamicProgramming/01backpack/#license","text":"This project is licensed under the MIT License - see the LICENSE.md file for details","title":"License"},{"location":"DynamicProgramming/01backpack/#acknowledgments","text":"Hat tip to anyone whose code was used Inspiration etc","title":"Acknowledgments"},{"location":"LeetCode0001_TwoSum/lc0001/","text":"1. Two Sum Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Java public int [] twoSum ( int [] nums , int target ) { HashMap Integer , Integer map = new HashMap (); for ( int i = 0 ; i nums . length ; i ++) { if ( map . containsKey ( target - nums [ i ]) map . get ( target - nums [ i ]) != i ) { return new int []{ map . get ( target - nums [ i ]), i }; } map . put ( nums [ i ], i ); } return new int []{}; } JavaScript var twoSum = function ( nums , target ) { var res = []; var map = new Map (); for ( var i = 0 ; i nums . length ; i ++ ) { if ( map . has ( target - nums [ i ])) { res . push ( map . get ( target - nums [ i ])); res . push ( i ); return res ; } map . set ( nums [ i ], i ); } return res ; } C++ public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int map ; for ( int i = 0 ; i nums . size (); i ++ ) { if ( map . count ( target - nums [ i ])) { return { map [ target - nums [ i ]], i }; } map [ nums [ i ]] = i ; } return {}; } C struct node { int key ; int val ; int count ; struct node * next ; }; struct table { int size ; struct node ** list ; }; struct table * createTable ( int size ) { struct table * t = ( struct table * ) malloc ( sizeof ( struct table )); t - size = size ; t - list = ( struct node ** ) malloc ( sizeof ( struct node * ) * size ); for ( int i = 0 ; i size ; i ++ ) { t - list [ i ] = NULL ; } return t ; } int hashCode ( struct table * t , int key ) { if ( key 0 ) return - ( key % t - size ); return key % t - size ; } void insert ( struct table * t , int key , int val ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * newNode = ( struct node * ) malloc ( sizeof ( struct node )); struct node * temp = list ; while ( temp ) { if ( temp - key == key ){ temp - count = temp - count + 1 ; return ; } temp = temp - next ; } newNode - key = key ; newNode - val = val ; newNode - count = 1 ; newNode - next = list ; t - list [ pos ] = newNode ; return ; } int search ( struct table * t , int key ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * temp = list ; while ( temp ) { if ( temp - key == key ) { return temp - val ; } temp = temp - next ; } return - 1 ; } int * twoSum ( int * nums , int numsSize , int target ) { int * res = malloc ( sizeof ( int ) * 2 ); struct table * t = createTable ( numsSize ); for ( int i = 0 ; i numsSize ; i ++ ) { int pos = search ( t , target - nums [ i ]); if ( pos - 1 ) { res [ 0 ] = pos ; res [ 1 ] = i ; return res ; } insert ( t , nums [ i ], i ); } return res ; }","title":"1 Two Sum"},{"location":"LeetCode0001_TwoSum/lc0001/#1-two-sum","text":"","title":"1. Two Sum"},{"location":"LeetCode0001_TwoSum/lc0001/#description","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.","title":"Description"},{"location":"LeetCode0001_TwoSum/lc0001/#example","text":"Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","title":"Example"},{"location":"LeetCode0001_TwoSum/lc0001/#java","text":"public int [] twoSum ( int [] nums , int target ) { HashMap Integer , Integer map = new HashMap (); for ( int i = 0 ; i nums . length ; i ++) { if ( map . containsKey ( target - nums [ i ]) map . get ( target - nums [ i ]) != i ) { return new int []{ map . get ( target - nums [ i ]), i }; } map . put ( nums [ i ], i ); } return new int []{}; }","title":"Java"},{"location":"LeetCode0001_TwoSum/lc0001/#javascript","text":"var twoSum = function ( nums , target ) { var res = []; var map = new Map (); for ( var i = 0 ; i nums . length ; i ++ ) { if ( map . has ( target - nums [ i ])) { res . push ( map . get ( target - nums [ i ])); res . push ( i ); return res ; } map . set ( nums [ i ], i ); } return res ; }","title":"JavaScript"},{"location":"LeetCode0001_TwoSum/lc0001/#c","text":"public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int map ; for ( int i = 0 ; i nums . size (); i ++ ) { if ( map . count ( target - nums [ i ])) { return { map [ target - nums [ i ]], i }; } map [ nums [ i ]] = i ; } return {}; }","title":"C++"},{"location":"LeetCode0001_TwoSum/lc0001/#c_1","text":"struct node { int key ; int val ; int count ; struct node * next ; }; struct table { int size ; struct node ** list ; }; struct table * createTable ( int size ) { struct table * t = ( struct table * ) malloc ( sizeof ( struct table )); t - size = size ; t - list = ( struct node ** ) malloc ( sizeof ( struct node * ) * size ); for ( int i = 0 ; i size ; i ++ ) { t - list [ i ] = NULL ; } return t ; } int hashCode ( struct table * t , int key ) { if ( key 0 ) return - ( key % t - size ); return key % t - size ; } void insert ( struct table * t , int key , int val ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * newNode = ( struct node * ) malloc ( sizeof ( struct node )); struct node * temp = list ; while ( temp ) { if ( temp - key == key ){ temp - count = temp - count + 1 ; return ; } temp = temp - next ; } newNode - key = key ; newNode - val = val ; newNode - count = 1 ; newNode - next = list ; t - list [ pos ] = newNode ; return ; } int search ( struct table * t , int key ) { int pos = hashCode ( t , key ); struct node * list = t - list [ pos ]; struct node * temp = list ; while ( temp ) { if ( temp - key == key ) { return temp - val ; } temp = temp - next ; } return - 1 ; } int * twoSum ( int * nums , int numsSize , int target ) { int * res = malloc ( sizeof ( int ) * 2 ); struct table * t = createTable ( numsSize ); for ( int i = 0 ; i numsSize ; i ++ ) { int pos = search ( t , target - nums [ i ]); if ( pos - 1 ) { res [ 0 ] = pos ; res [ 1 ] = i ; return res ; } insert ( t , nums [ i ], i ); } return res ; }","title":"C"},{"location":"LeetCode0101_SymmetricTree/lc0101/","text":"101. Symmetric Tree Description Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). Example For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3 Java(Recursive) public boolean isSymmetric ( TreeNode root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); } boolean helper ( TreeNode left , TreeNode right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; boolean temp = true ; return temp helper ( left . left , right . right ) helper ( left . right , right . left ); } Java(Iterative) public boolean isSymmetric ( TreeNode root ) { Queue TreeNode queue = new LinkedList (); queue . offer ( root ); queue . offer ( root ); while (! queue . isEmpty ()) { TreeNode left = queue . poll (); TreeNode right = queue . poll (); if ( left == null right == null ) continue ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; queue . offer ( left . left ); queue . offer ( right . right ); queue . offer ( left . right ); queue . offer ( right . left ); } return true ; } JavaScript var isSymmetric = function ( root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); }; function helper ( left , right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; return helper ( left . left , right . right ) helper ( left . right , right . left ); } C++ public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return helper ( root - left , root - right ); } public : bool helper ( TreeNode * left , TreeNode * right ) { if ( ! left ! right ) return true ; if ( ! left || ! right ) return false ; if ( left - val != right - val ) return false ; return helper ( left - left , right - right ) helper ( left - right , right - left ); }","title":"101 Symmetric Tree"},{"location":"LeetCode0101_SymmetricTree/lc0101/#101-symmetric-tree","text":"","title":"101. Symmetric Tree"},{"location":"LeetCode0101_SymmetricTree/lc0101/#description","text":"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).","title":"Description"},{"location":"LeetCode0101_SymmetricTree/lc0101/#example","text":"For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3","title":"Example"},{"location":"LeetCode0101_SymmetricTree/lc0101/#javarecursive","text":"public boolean isSymmetric ( TreeNode root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); } boolean helper ( TreeNode left , TreeNode right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; boolean temp = true ; return temp helper ( left . left , right . right ) helper ( left . right , right . left ); }","title":"Java(Recursive)"},{"location":"LeetCode0101_SymmetricTree/lc0101/#javaiterative","text":"public boolean isSymmetric ( TreeNode root ) { Queue TreeNode queue = new LinkedList (); queue . offer ( root ); queue . offer ( root ); while (! queue . isEmpty ()) { TreeNode left = queue . poll (); TreeNode right = queue . poll (); if ( left == null right == null ) continue ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; queue . offer ( left . left ); queue . offer ( right . right ); queue . offer ( left . right ); queue . offer ( right . left ); } return true ; }","title":"Java(Iterative)"},{"location":"LeetCode0101_SymmetricTree/lc0101/#javascript","text":"var isSymmetric = function ( root ) { if ( root == null ) return true ; return helper ( root . left , root . right ); }; function helper ( left , right ) { if ( left == null right == null ) return true ; if ( left == null || right == null ) return false ; if ( left . val != right . val ) return false ; return helper ( left . left , right . right ) helper ( left . right , right . left ); }","title":"JavaScript"},{"location":"LeetCode0101_SymmetricTree/lc0101/#c","text":"public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return helper ( root - left , root - right ); } public : bool helper ( TreeNode * left , TreeNode * right ) { if ( ! left ! right ) return true ; if ( ! left || ! right ) return false ; if ( left - val != right - val ) return false ; return helper ( left - left , right - right ) helper ( left - right , right - left ); }","title":"C++"},{"location":"LeetCode0282_ExpressionAddOperators/lc0282/","text":"282. Expression Add Operators Description Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1. Input: num = 123 , target = 6 Output: [ 1+2+3 , 1*2*3 ] 2. Input: num = 232 , target = 8 Output: [ 2*3+2 , 2+3*2 ] 3. Input: num = 105 , target = 5 Output: [ 1*0+5 , 10-5 ] 4. Input: num = 00 , target = 0 Output: [ 0+0 , 0-0 , 0*0 ] 5. Input: num = 3456237490 , target = 9191 Output: [] Java public List String addOperators ( String num , int target ) { List String res = new ArrayList (); if ( num == null || num . length () == 0 ) return res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } public void helper ( String num , String temp , int pos , long cur , long prev , int target , List String res ) { if ( pos == num . length ()) { if ( cur == target ) { res . add ( temp ); } return ; } for ( int i = pos ; i num . length (); i ++) { if ( i != pos num . charAt ( pos ) == 0 ) break ; long t = Long . parseLong ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , temp + t , i + 1 , t , t , target , res ); } else { helper ( num , temp + + + t , i + 1 , cur + t , t , target , res ); helper ( num , temp + - + t , i + 1 , cur - t , - t , target , res ); helper ( num , temp + * + t , i + 1 , cur - prev + t * prev , t * prev , target , res ); } } } JavaScript var addOperators = function ( num , target ) { var res = []; helper ( num , , 0 , 0 , 0 , target , res ); return res ; }; function helper ( num , temp , pos , cur , prev , target , res ) { if ( pos === num . length ) { if ( cur === target ) { res . push ( temp ); } return ; } for ( let i = pos ; i num . length ; i ++ ) { if ( i != pos num . charAt ( pos ) == 0 ) break ; let n = parseInt ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , + n , i + 1 , n , n , target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + n , n , target , res ); helper ( num , temp + - + n , i + 1 , cur - n , - n , target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + n * prev , n * prev , target , res ); } } } C++ public : vector string addOperators ( string num , int target ) { vector string res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } private : void helper ( string num , string temp , int pos , long cur , long prev , int target , vector string res ) { if ( pos == num . size ()) { if ( cur == target ) { res . push_back ( temp ); } return ; } for ( int i = pos ; i num . size (); i ++ ) { if ( i != pos num [ pos ] == 0 ) break ; string n = num . substr ( pos , i - pos + 1 ); if ( pos == 0 ) { helper ( num , + n , i + 1 , stoll ( n ), stoll ( n ), target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + stoll ( n ), stoll ( n ), target , res ); helper ( num , temp + - + n , i + 1 , cur - stoll ( n ), - stoll ( n ), target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + prev * stoll ( n ), prev * stoll ( n ), target , res ); } } }","title":"282 Expression Add Operators"},{"location":"LeetCode0282_ExpressionAddOperators/lc0282/#282-expression-add-operators","text":"","title":"282. Expression Add Operators"},{"location":"LeetCode0282_ExpressionAddOperators/lc0282/#description","text":"Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.","title":"Description"},{"location":"LeetCode0282_ExpressionAddOperators/lc0282/#example","text":"1. Input: num = 123 , target = 6 Output: [ 1+2+3 , 1*2*3 ] 2. Input: num = 232 , target = 8 Output: [ 2*3+2 , 2+3*2 ] 3. Input: num = 105 , target = 5 Output: [ 1*0+5 , 10-5 ] 4. Input: num = 00 , target = 0 Output: [ 0+0 , 0-0 , 0*0 ] 5. Input: num = 3456237490 , target = 9191 Output: []","title":"Example"},{"location":"LeetCode0282_ExpressionAddOperators/lc0282/#java","text":"public List String addOperators ( String num , int target ) { List String res = new ArrayList (); if ( num == null || num . length () == 0 ) return res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } public void helper ( String num , String temp , int pos , long cur , long prev , int target , List String res ) { if ( pos == num . length ()) { if ( cur == target ) { res . add ( temp ); } return ; } for ( int i = pos ; i num . length (); i ++) { if ( i != pos num . charAt ( pos ) == 0 ) break ; long t = Long . parseLong ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , temp + t , i + 1 , t , t , target , res ); } else { helper ( num , temp + + + t , i + 1 , cur + t , t , target , res ); helper ( num , temp + - + t , i + 1 , cur - t , - t , target , res ); helper ( num , temp + * + t , i + 1 , cur - prev + t * prev , t * prev , target , res ); } } }","title":"Java"},{"location":"LeetCode0282_ExpressionAddOperators/lc0282/#javascript","text":"var addOperators = function ( num , target ) { var res = []; helper ( num , , 0 , 0 , 0 , target , res ); return res ; }; function helper ( num , temp , pos , cur , prev , target , res ) { if ( pos === num . length ) { if ( cur === target ) { res . push ( temp ); } return ; } for ( let i = pos ; i num . length ; i ++ ) { if ( i != pos num . charAt ( pos ) == 0 ) break ; let n = parseInt ( num . substring ( pos , i + 1 )); if ( pos == 0 ) { helper ( num , + n , i + 1 , n , n , target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + n , n , target , res ); helper ( num , temp + - + n , i + 1 , cur - n , - n , target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + n * prev , n * prev , target , res ); } } }","title":"JavaScript"},{"location":"LeetCode0282_ExpressionAddOperators/lc0282/#c","text":"public : vector string addOperators ( string num , int target ) { vector string res ; helper ( num , , 0 , 0 , 0 , target , res ); return res ; } private : void helper ( string num , string temp , int pos , long cur , long prev , int target , vector string res ) { if ( pos == num . size ()) { if ( cur == target ) { res . push_back ( temp ); } return ; } for ( int i = pos ; i num . size (); i ++ ) { if ( i != pos num [ pos ] == 0 ) break ; string n = num . substr ( pos , i - pos + 1 ); if ( pos == 0 ) { helper ( num , + n , i + 1 , stoll ( n ), stoll ( n ), target , res ); } else { helper ( num , temp + + + n , i + 1 , cur + stoll ( n ), stoll ( n ), target , res ); helper ( num , temp + - + n , i + 1 , cur - stoll ( n ), - stoll ( n ), target , res ); helper ( num , temp + * + n , i + 1 , cur - prev + prev * stoll ( n ), prev * stoll ( n ), target , res ); } } }","title":"C++"},{"location":"LeetCode0339_EvaluateDivision/lc0339/","text":"399. Evaluate Division Description Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector equations, vector values, vector queries ,where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector . According to the example above: equations = [ [ a , b ], [ b , c ] ], values = [2.0, 3.0], queries = [ [ a , c ], [ b , a ], [ a , e ], [ a , a ], [ x , x ] ]. Java(DFS) Map String , Map String , Double map ; public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { map = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { String x = equations [ i ][ 0 ]; String y = equations [ i ][ 1 ]; double value = values [ i ]; map . putIfAbsent ( x , new HashMap String , Double ()); map . putIfAbsent ( y , new HashMap String , Double ()); map . get ( x ). put ( y , value ); map . get ( y ). put ( x , 1.0 / value ); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! map . containsKey ( queries [ i ][ 0 ]) || ! map . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = dfs ( queries [ i ][ 0 ], queries [ i ][ 1 ], new HashSet String ()); } return res ; } double dfs ( String cur , String target , Set String set ) { if ( cur . equals ( target )) return 1.0 ; set . add ( cur ); if (! map . containsKey ( cur )) return - 1.0 ; for ( String neighbor : map . get ( cur ). keySet ()) { if ( set . contains ( neighbor )) continue ; double t = dfs ( neighbor , target , set ); if ( t - 1.0 ) return t * map . get ( cur ). get ( neighbor ); } return - 1.0 ; } Java(Union Find) class Node { String parent ; double ratio ; Node ( String parent , double ratio ) { this . parent = parent ; this . ratio = ratio ; } } class UnionFindSet { Map String , Node parents = new HashMap (); Node find ( String s ) { if (! parents . containsKey ( s )) return null ; Node n = parents . get ( s ); if (! n . parent . equals ( s )) { Node t = find ( n . parent ); n . parent = t . parent ; n . ratio *= t . ratio ; } return n ; } void union ( String s , String p , double ratio ) { boolean hasS = parents . containsKey ( s ); boolean hasP = parents . containsKey ( p ); if (! hasS ! hasP ) { parents . put ( s , new Node ( p , ratio )); parents . put ( p , new Node ( p , 1.0 )); } else if (! hasP ){ parents . put ( p , new Node ( s , 1.0 / ratio )); } else if (! hasS ) { parents . put ( s , new Node ( p , ratio )); } else { Node pS = find ( s ); Node pP = find ( p ); pS . parent = pP . parent ; pS . ratio = ratio / pS . ratio * pP . ratio ; } } } public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { UnionFindSet uf = new UnionFindSet (); for ( int i = 0 ; i equations . length ; i ++) { uf . union ( equations [ i ][ 0 ], equations [ i ][ 1 ], values [ i ]); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { Node root_x = uf . find ( queries [ i ][ 0 ]), root_y = uf . find ( queries [ i ][ 1 ]); if ( root_x == null || root_y == null || ! root_x . parent . equals ( root_y . parent )) res [ i ] = - 1.0 ; else res [ i ] = root_x . ratio / root_y . ratio ; } return res ; } Java(Floyd Warshall Algorithm) public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { HashMap String , HashMap String , Double graph = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { graph . computeIfAbsent ( equations [ i ][ 0 ], f - new HashMap ()). put ( equations [ i ][ 1 ], values [ i ]); graph . computeIfAbsent ( equations [ i ][ 1 ], f - new HashMap ()). put ( equations [ i ][ 0 ], 1.0 / values [ i ]); } for ( String mid : graph . keySet ()) { for ( String src : graph . get ( mid ). keySet ()) { for ( String dest : graph . get ( mid ). keySet ()) { double val = graph . get ( src ). get ( mid ) * graph . get ( mid ). get ( dest ); graph . get ( src ). put ( dest , val ); } } } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! graph . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = graph . get ( queries [ i ][ 0 ]). getOrDefault ( queries [ i ][ 1 ], - 1.0 ); } return res ; } JavaScript var calcEquation = function ( equations , values , queries ) { var map = new Map (), valueMap = new Map (); for ( let i = 0 ; i equations . length ; i ++ ) { let x = equations [ i ][ 0 ]; let y = equations [ i ][ 1 ]; let v = values [ i ]; if ( ! map . has ( x )) { map . set ( x , []); valueMap . set ( x , []) } if ( ! map . has ( y )) { map . set ( y , []); valueMap . set ( y , []); } map . get ( x ). push ( y ); map . get ( y ). push ( x ); valueMap . get ( x ). push ( v ); valueMap . get ( y ). push ( 1.0 / v ); } var res = []; for ( let j = 0 ; j queries . length ; j ++ ) { let x = queries [ j ][ 0 ]; let y = queries [ j ][ 1 ]; if ( ! map . has ( x ) || ! map . has ( y )) { res . push ( - 1.0 ); continue ; } res . push ( dfs ( x , y , map , valueMap , new Set ())); } return res ; }; function dfs ( x , y , map , valueMap , set ) { if ( x === y ) return 1.0 ; set . add ( x ); let nextList = map . get ( x ); let valueList = valueMap . get ( x ); for ( let i = 0 ; i nextList . length ; i ++ ) { if ( set . has ( nextList [ i ])) continue ; let t = dfs ( nextList [ i ], y , map , valueMap , set ); if ( t - 1.0 ) return valueList [ i ] * t ; } return - 1.0 ; } C++(DFS) public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , unordered_map string , double map ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; map [ x ][ y ] = v ; map [ y ][ x ] = 1.0 / v ; } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! map . count ( x ) || ! map . count ( y )) { res . push_back ( - 1.0 ); continue ; } else { unordered_set string set ; res . push_back ( dfs ( x , y , map , set )); } } return res ; } private : double dfs ( const string x , const string y , unordered_map string , unordered_map string , double map , unordered_set string set ) { if ( x == y ) return 1.0 ; set . insert ( x ); for ( const auto pair : map [ x ]) { const string next = pair . first ; if ( set . count ( next )) continue ; double t = dfs ( next , y , map , set ); if ( t - 1.0 ) return map [ x ][ next ] * t ; } return - 1.0 ; } C++(Union Find) public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , pair string , double parents ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; if ( ! parents . count ( x ) ! parents . count ( y )) { parents [ x ] = { y , v }; parents [ y ] = { y , 1.0 }; } else if ( ! parents . count ( y )) { parents [ y ] = { x , 1.0 / v }; } else if ( ! parents . count ( x )) { parents [ x ] = { y , v }; } else { const auto root_x = find ( x , parents ); const auto root_y = find ( y , parents ); parents [ root_x . first ] = { root_y . first , v / root_x . second * root_y . second }; } } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! parents . count ( x ) || ! parents . count ( y )) { res . push_back ( - 1.0 ); continue ; } auto root_x = find ( x , parents ); auto root_y = find ( y , parents ); if ( root_x . first != root_y . first ) { res . push_back ( - 1.0 ); } else { res . push_back ( root_x . second / root_y . second ); } } return res ; } private : pair string , double find ( const string n , unordered_map string , pair string , double parents ) { if ( n != parents [ n ]. first ) { const auto p = find ( parents [ n ]. first , parents ); parents [ n ]. first = p . first ; parents [ n ]. second *= p . second ; } return parents [ n ]; }","title":"399 Evaluate Division"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#399-evaluate-division","text":"","title":"399. Evaluate Division"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#description","text":"Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.","title":"Description"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#example","text":"Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector equations, vector values, vector queries ,where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector . According to the example above: equations = [ [ a , b ], [ b , c ] ], values = [2.0, 3.0], queries = [ [ a , c ], [ b , a ], [ a , e ], [ a , a ], [ x , x ] ].","title":"Example"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#javadfs","text":"Map String , Map String , Double map ; public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { map = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { String x = equations [ i ][ 0 ]; String y = equations [ i ][ 1 ]; double value = values [ i ]; map . putIfAbsent ( x , new HashMap String , Double ()); map . putIfAbsent ( y , new HashMap String , Double ()); map . get ( x ). put ( y , value ); map . get ( y ). put ( x , 1.0 / value ); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! map . containsKey ( queries [ i ][ 0 ]) || ! map . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = dfs ( queries [ i ][ 0 ], queries [ i ][ 1 ], new HashSet String ()); } return res ; } double dfs ( String cur , String target , Set String set ) { if ( cur . equals ( target )) return 1.0 ; set . add ( cur ); if (! map . containsKey ( cur )) return - 1.0 ; for ( String neighbor : map . get ( cur ). keySet ()) { if ( set . contains ( neighbor )) continue ; double t = dfs ( neighbor , target , set ); if ( t - 1.0 ) return t * map . get ( cur ). get ( neighbor ); } return - 1.0 ; }","title":"Java(DFS)"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#javaunion-find","text":"class Node { String parent ; double ratio ; Node ( String parent , double ratio ) { this . parent = parent ; this . ratio = ratio ; } } class UnionFindSet { Map String , Node parents = new HashMap (); Node find ( String s ) { if (! parents . containsKey ( s )) return null ; Node n = parents . get ( s ); if (! n . parent . equals ( s )) { Node t = find ( n . parent ); n . parent = t . parent ; n . ratio *= t . ratio ; } return n ; } void union ( String s , String p , double ratio ) { boolean hasS = parents . containsKey ( s ); boolean hasP = parents . containsKey ( p ); if (! hasS ! hasP ) { parents . put ( s , new Node ( p , ratio )); parents . put ( p , new Node ( p , 1.0 )); } else if (! hasP ){ parents . put ( p , new Node ( s , 1.0 / ratio )); } else if (! hasS ) { parents . put ( s , new Node ( p , ratio )); } else { Node pS = find ( s ); Node pP = find ( p ); pS . parent = pP . parent ; pS . ratio = ratio / pS . ratio * pP . ratio ; } } } public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { UnionFindSet uf = new UnionFindSet (); for ( int i = 0 ; i equations . length ; i ++) { uf . union ( equations [ i ][ 0 ], equations [ i ][ 1 ], values [ i ]); } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { Node root_x = uf . find ( queries [ i ][ 0 ]), root_y = uf . find ( queries [ i ][ 1 ]); if ( root_x == null || root_y == null || ! root_x . parent . equals ( root_y . parent )) res [ i ] = - 1.0 ; else res [ i ] = root_x . ratio / root_y . ratio ; } return res ; }","title":"Java(Union Find)"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#javafloyd-warshall-algorithm","text":"public double [] calcEquation ( String [][] equations , double [] values , String [][] queries ) { HashMap String , HashMap String , Double graph = new HashMap (); for ( int i = 0 ; i equations . length ; i ++) { graph . computeIfAbsent ( equations [ i ][ 0 ], f - new HashMap ()). put ( equations [ i ][ 1 ], values [ i ]); graph . computeIfAbsent ( equations [ i ][ 1 ], f - new HashMap ()). put ( equations [ i ][ 0 ], 1.0 / values [ i ]); } for ( String mid : graph . keySet ()) { for ( String src : graph . get ( mid ). keySet ()) { for ( String dest : graph . get ( mid ). keySet ()) { double val = graph . get ( src ). get ( mid ) * graph . get ( mid ). get ( dest ); graph . get ( src ). put ( dest , val ); } } } double [] res = new double [ queries . length ]; for ( int i = 0 ; i queries . length ; i ++) { if (! graph . containsKey ( queries [ i ][ 0 ])) res [ i ] = - 1.0 ; else res [ i ] = graph . get ( queries [ i ][ 0 ]). getOrDefault ( queries [ i ][ 1 ], - 1.0 ); } return res ; }","title":"Java(Floyd Warshall Algorithm)"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#javascript","text":"var calcEquation = function ( equations , values , queries ) { var map = new Map (), valueMap = new Map (); for ( let i = 0 ; i equations . length ; i ++ ) { let x = equations [ i ][ 0 ]; let y = equations [ i ][ 1 ]; let v = values [ i ]; if ( ! map . has ( x )) { map . set ( x , []); valueMap . set ( x , []) } if ( ! map . has ( y )) { map . set ( y , []); valueMap . set ( y , []); } map . get ( x ). push ( y ); map . get ( y ). push ( x ); valueMap . get ( x ). push ( v ); valueMap . get ( y ). push ( 1.0 / v ); } var res = []; for ( let j = 0 ; j queries . length ; j ++ ) { let x = queries [ j ][ 0 ]; let y = queries [ j ][ 1 ]; if ( ! map . has ( x ) || ! map . has ( y )) { res . push ( - 1.0 ); continue ; } res . push ( dfs ( x , y , map , valueMap , new Set ())); } return res ; }; function dfs ( x , y , map , valueMap , set ) { if ( x === y ) return 1.0 ; set . add ( x ); let nextList = map . get ( x ); let valueList = valueMap . get ( x ); for ( let i = 0 ; i nextList . length ; i ++ ) { if ( set . has ( nextList [ i ])) continue ; let t = dfs ( nextList [ i ], y , map , valueMap , set ); if ( t - 1.0 ) return valueList [ i ] * t ; } return - 1.0 ; }","title":"JavaScript"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#cdfs","text":"public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , unordered_map string , double map ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; map [ x ][ y ] = v ; map [ y ][ x ] = 1.0 / v ; } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! map . count ( x ) || ! map . count ( y )) { res . push_back ( - 1.0 ); continue ; } else { unordered_set string set ; res . push_back ( dfs ( x , y , map , set )); } } return res ; } private : double dfs ( const string x , const string y , unordered_map string , unordered_map string , double map , unordered_set string set ) { if ( x == y ) return 1.0 ; set . insert ( x ); for ( const auto pair : map [ x ]) { const string next = pair . first ; if ( set . count ( next )) continue ; double t = dfs ( next , y , map , set ); if ( t - 1.0 ) return map [ x ][ next ] * t ; } return - 1.0 ; }","title":"C++(DFS)"},{"location":"LeetCode0339_EvaluateDivision/lc0339/#cunion-find","text":"public : vector double calcEquation ( vector pair string , string equations , vector double values , vector pair string , string queries ) { unordered_map string , pair string , double parents ; for ( int i = 0 ; i equations . size (); i ++ ) { const string x = equations [ i ]. first ; const string y = equations [ i ]. second ; const double v = values [ i ]; if ( ! parents . count ( x ) ! parents . count ( y )) { parents [ x ] = { y , v }; parents [ y ] = { y , 1.0 }; } else if ( ! parents . count ( y )) { parents [ y ] = { x , 1.0 / v }; } else if ( ! parents . count ( x )) { parents [ x ] = { y , v }; } else { const auto root_x = find ( x , parents ); const auto root_y = find ( y , parents ); parents [ root_x . first ] = { root_y . first , v / root_x . second * root_y . second }; } } vector double res ; for ( const auto pair : queries ) { const string x = pair . first ; const string y = pair . second ; if ( ! parents . count ( x ) || ! parents . count ( y )) { res . push_back ( - 1.0 ); continue ; } auto root_x = find ( x , parents ); auto root_y = find ( y , parents ); if ( root_x . first != root_y . first ) { res . push_back ( - 1.0 ); } else { res . push_back ( root_x . second / root_y . second ); } } return res ; } private : pair string , double find ( const string n , unordered_map string , pair string , double parents ) { if ( n != parents [ n ]. first ) { const auto p = find ( parents [ n ]. first , parents ); parents [ n ]. first = p . first ; parents [ n ]. second *= p . second ; } return parents [ n ]; }","title":"C++(Union Find)"},{"location":"LeetCode0416_PartitionEqualSubsetSum/lc0416/","text":"416. Partition Equal Subset Sum Description Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example Example 1 Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Java public boolean canPartition ( int [] nums ) { int sum = 0 ; for ( int num : nums ) sum += num ; if ( sum % 2 != 0 ) return false ; int n = nums . length ; boolean [][] dp = new boolean [ n + 1 ][ sum + 1 ]; for ( int i = 0 ; i = nums . length ; i ++) dp [ i ][ 0 ] = true ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = sum ; j ++) { if ( nums [ i - 1 ] j ) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; continue ; } dp [ i ][ j ] = dp [ i - 1 ][ j - nums [ i - 1 ]] | dp [ i - 1 ][ j ]; } if ( dp [ i ][ sum / 2 ] == true ) return true ; } return false ; } JavaScript var canPartition = function ( nums ) { if ( ! nums || nums . length == 0 ) return false ; let sum = nums . reduce (( a , b ) = ( a + b ), 0 ); if ( sum % 2 == 1 ) return false ; sum /= 2 let dp = new Array ( sum + 1 ); dp . fill ( false ); dp [ 0 ] = true ; for ( let i = 1 ; i = nums . length ; i ++ ) { for ( let j = sum ; j = nums [ i - 1 ]; j -- ) { dp [ j ] = dp [ j ] || dp [ j - nums [ i - 1 ]]; } } return dp [ sum ]; }; C++(DFS) public : bool canPartition ( vector int nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); if ( sum 1 ) return false ; vector bool dp ( sum / 2 + 1 , false ); dp [ 0 ] = true ; for ( int num : nums ) { for ( int i = sum / 2 ; i = num ; -- i ) { dp [ i ] = dp [ i ] || dp [ i - num ]; } } return dp [ sum / 2 ]; }","title":"416 Partition Equal Subset Sum"},{"location":"LeetCode0416_PartitionEqualSubsetSum/lc0416/#416-partition-equal-subset-sum","text":"","title":"416. Partition Equal Subset Sum"},{"location":"LeetCode0416_PartitionEqualSubsetSum/lc0416/#description","text":"Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200.","title":"Description"},{"location":"LeetCode0416_PartitionEqualSubsetSum/lc0416/#example","text":"Example 1 Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.","title":"Example"},{"location":"LeetCode0416_PartitionEqualSubsetSum/lc0416/#java","text":"public boolean canPartition ( int [] nums ) { int sum = 0 ; for ( int num : nums ) sum += num ; if ( sum % 2 != 0 ) return false ; int n = nums . length ; boolean [][] dp = new boolean [ n + 1 ][ sum + 1 ]; for ( int i = 0 ; i = nums . length ; i ++) dp [ i ][ 0 ] = true ; for ( int i = 1 ; i = n ; i ++) { for ( int j = 1 ; j = sum ; j ++) { if ( nums [ i - 1 ] j ) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; continue ; } dp [ i ][ j ] = dp [ i - 1 ][ j - nums [ i - 1 ]] | dp [ i - 1 ][ j ]; } if ( dp [ i ][ sum / 2 ] == true ) return true ; } return false ; }","title":"Java"},{"location":"LeetCode0416_PartitionEqualSubsetSum/lc0416/#javascript","text":"var canPartition = function ( nums ) { if ( ! nums || nums . length == 0 ) return false ; let sum = nums . reduce (( a , b ) = ( a + b ), 0 ); if ( sum % 2 == 1 ) return false ; sum /= 2 let dp = new Array ( sum + 1 ); dp . fill ( false ); dp [ 0 ] = true ; for ( let i = 1 ; i = nums . length ; i ++ ) { for ( let j = sum ; j = nums [ i - 1 ]; j -- ) { dp [ j ] = dp [ j ] || dp [ j - nums [ i - 1 ]]; } } return dp [ sum ]; };","title":"JavaScript"},{"location":"LeetCode0416_PartitionEqualSubsetSum/lc0416/#cdfs","text":"public : bool canPartition ( vector int nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); if ( sum 1 ) return false ; vector bool dp ( sum / 2 + 1 , false ); dp [ 0 ] = true ; for ( int num : nums ) { for ( int i = sum / 2 ; i = num ; -- i ) { dp [ i ] = dp [ i ] || dp [ i - num ]; } } return dp [ sum / 2 ]; }","title":"C++(DFS)"}]}